<!DOCTYPE html>
<html>
    <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" >
    <title>
        
        Java并发编程笔记（三）JDK并发包详解2 · 翁玉川Miko个人博客
        
    </title>
    <link rel="icon" href= /assets/favicon.ico>
    <!-- TODO: 在font-face加载完毕后改变字体  -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.28/webfontloader.js"></script>
    <!-- 提前加载place holder  -->
    <style type="text/css">
        @font-face {
            font-family: 'Oswald-Regular';
            src: url(/font/Oswald-Regular.ttf);
        }
    </style>
    <style type="text/css">
        .site-intro {
            position: relative;
            width: 100%;
            height: 50vh;
            overflow: hidden;
            box-shadow: -0.1rem 0 0.5rem 0 rgba(0, 0, 0, 0.5);
        }
        .site-intro-placeholder {
            position: absolute;
            z-index: -2;
            top: 0;
            left: 0px;
            width: calc(100% + 300px);
            height: 100%;
            background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
            background-position: center center;
            transform: translate3d(-226px, 0, 0);
            animation: gradient-move 2.5s ease-out 0s 1;
        }
        @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }
</style>
    <link rel="stylesheet" href = /css/style.css?v=20171227 />
    <script src="//cdn.staticfile.org/jquery/3.2.1/jquery.min.js" defer></script>
    
    <script src="/scripts/main.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >Yuchuan Weng.Miko Tech-Blog.</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">Java并发编程笔记（三）JDK并发包详解2</a>
            </div>
    </div>
    
    <a class="home-link" href=/>Yuchuan Weng.Miko Tech-Blog.</a>
</header>
    <div class="wrapper">
        <div class="site-intro">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-img" style="background-image: url(http://oumn0o088.bkt.clouddn.com/post-bg.jpg)"></div>
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            Java并发编程笔记（三）JDK并发包详解2
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <!-- 文章页标签  -->
            
                <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-href = 并发编程>并发编程</a>
    
</div>
            
            <script>window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": "", "bdMini": "2", "bdMiniList": false, "bdPic": "", "bdStyle": "1", "bdSize": "16" }, "share": {} }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = '/scripts/baidu.js?cdnversion=' + ~(-new Date() / 36e5)];</script>
            <div class="post-intro-meta">
                <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                <span class="post-intro-time">2017/07/01</span>
                <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                    <span class="iconfont-archer">&#xe604;</span>
                    <span id="busuanzi_value_page_pv"></span>
                </span>
                <span class="shareWrapper">
                    <span class="iconfont-archer shareIcon">
                        &#xe601;
                    </span>
                    <span class="bdsharebuttonbox">
                        <a href="#" class="bds_more shareText" data-cmd="more">Share</a>
                    </span>
                </span>
            </div>
        
    </div>
</div>
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <script>
            var browser = {
                    versions: function () {
                        var u = window.navigator.userAgent;
                        return {
                            userAgent: u,
                            trident: u.indexOf('Trident') > -1, //IE内核
                            presto: u.indexOf('Presto') > -1, //opera内核
                            webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
                            gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
                            mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
                            ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
                            android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
                            iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
                            iPad: u.indexOf('iPad') > -1, //是否为iPad
                            webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
                            weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
                            uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
                        };
                    }()
                }

            function fontLoaded(){
                console.log('font loaded');
                if (document.getElementsByClassName('site-intro-meta')) {
                    document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
                    document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
                    var postIntroTags = document.getElementsByClassName('post-intro-tags')[0],
                        postIntroMeat = document.getElementsByClassName('post-intro-meta')[0];
                        if (postIntroTags) {
                            postIntroTags.classList.add('post-fade-in');
                        }
                        if (postIntroMeat) {
                            postIntroMeat.classList.add('post-fade-in');
                        }
                    }
                }
                
            console.log("userAgent:" + browser.versions.userAgent);
            // UC不支持跨域，所以直接显示
            if (browser.versions.uc) {
                console.log("UCBrowser");
                fontLoaded();
            } else {
                WebFont.load({
                    custom: {
                        families: ['Oswald-Regular']
                    },
                    loading: function () {  //所有字体开始加载
                        // console.log('loading');
                    },
                    active: function () {  //所有字体已渲染
                        fontLoaded();
                    },
                    inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
                        console.log('inactive: timeout');
                        fontLoaded();
                    },
                    timeout: 7000 // Set the timeout to two seconds
                });
            }
        </script>
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h1 id="线程复用：线程池"><a href="#线程复用：线程池" class="headerlink" title="线程复用：线程池"></a>线程复用：线程池</h1><p>一个系统中，如果盲目大量地创建线程对系统是有伤害的。大量的线程回收也会给GC增加很大的压力，延长GC的停顿时间，同数据库连接池一样，为了避免创建和销毁线程的高开销，对线程进行复用，需要时从线程池中获取线程，用完还给线程池，让线程池 空闲线程 和 工作线程 处于一个动态平衡之中。</p>
<h1 id="不要重复发明轮子：JDK对线程池的支持"><a href="#不要重复发明轮子：JDK对线程池的支持" class="headerlink" title="不要重复发明轮子：JDK对线程池的支持"></a>不要重复发明轮子：JDK对线程池的支持</h1><p>为了更好地控制多线程，JDK提供了一套Executor框架，帮助开发人员进行线程控制，其本质就是线程池。包含了许许多多的方法，以上成员均在java.util.concurrent包中，都是jdk并发包的核心类。其中ThreadPoolExecutor表示一个线程池。<br>Executor接口提供了各种类型的线程池，主要有以下工厂方法：<br>子接口ExecutorService：<br><code>public static ExecutorService newFixedThreadPool(int nThreads)</code><br><code>public static ExecutorService newSingleThreadExecutor()</code><br><code>public static ExecutorService newCachedThreadPool()</code><br><code>public static ScheduledExecutorService newSingleThreadScheduledExecutor()</code><br><code>public static ScheduleExecutorService newScheduledThreadPool (int corePoolSizze)</code><br>以上工厂方法提供了不同特性的线程池 具体说明如下：</p>
<ul>
<li>newFixedThreadPool()方法：返回一个固定数量的线程池，如果有空闲线程立即执行，如果没有则新任务会暂存在一个等待队列中，待有线程空闲时便处理任务队列中的任务。</li>
<li>newSingleThreadExecutor()方法：返回一个单线程的线程池，如果没有空闲线程复用那么进入等待队列等待。</li>
<li>newCachedThreadPool()方法：该方法返回一个动态的线程池，如果没有空闲线程可以复用，那么就创建一个新线程，创建完毕后返回复用</li>
<li>newSingleThreadScheduledExecutor()方法：返回一个线程池大小为一，可以定时执行任务的线程池（或者周期性执行任务）</li>
<li>newScheduledThreadPool()方法：该方法也返回一个可以执行定时任务 指定大小的线程池。</li>
</ul>
<p>一个基本的<code>newFixedThreadPool()</code>示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolDemo1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">//打印当前线程部分信息</span></span><br><span class="line">			System.out.println(<span class="string">"Thread ID="</span>+Thread.currentThread().getId()+<span class="string">""</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//休息1s</span></span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">			PoolDemo1 poolDemo1 = <span class="keyword">new</span> PoolDemo1();</span><br><span class="line">			<span class="comment">//构建线程池固定大小</span></span><br><span class="line">			<span class="comment">//ExecutorService pool = Executors.newFixedThreadPool(5);</span></span><br><span class="line">			<span class="comment">//构建动态的线程池 这样的话十个线程ID都不一样新建了10个</span></span><br><span class="line">			ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">			<span class="comment">//由于线程池只有5个固定线程 所以 启动5个后会停顿1s然后线程的ID可以看出接下来的5个是和原来的一样的</span></span><br><span class="line">				pool.submit(poolDemo1);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//停止操作</span></span><br><span class="line">			pool.shutdown();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>计划任务newScheduledThreadPool:<br>另一个值得注意的方法是newScheduledThreadPool 它返回一个ScheduledExcutorService对象，可以根据时间需要对线程进行调度。它的一些主要方法如下：<br><code>public ScheduledFuture&lt;?&gt; schedule(Runnable command,long delay,TimeUnit unit)</code>;<br><code>public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,long initialDelay,long period,TimeUnit unit)</code>;<br><code>public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,long initialDelay,long delay,TimeUnit unit)</code>;</p>
<p>与其他几个线程不同，ScheduledExecutorService并不一定会立即安排执行任务，它是起到了计划任务的作用，会在指定的时间对任务进行周期性地调度。schedule会在给定时间进行一次调度，而二三两个方法都是进行周期性地调度，但是有小小的区别。<br>FixedRate()任务即意思是每一个任务在一个周期性任务开始执行时间为起点，调度固定频率周期的任务，而FixDelay则是在上一个任务结束以后，在经过delay时间进行任务调度。代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">			scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="comment">//scheduledAtFixedRate 为周期性固定频率调用</span></span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="comment">// 每5s周期性地调用</span></span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">						System.out.println(<span class="string">"周期线程任务执行~~~"</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//0秒开始 执行周期为5s 指定单位 如果任务时间超过了周期时间（例如8s） 那么以任务时间为周期 如果采用</span></span><br><span class="line">				<span class="comment">//scheduleWithFixedDelay() 那么任务实际时间为 8s+5s = 13s</span></span><br><span class="line">			&#125;, <span class="number">0</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>另外一个值得注意的问题就是异常处理，因为遇到异常后续任务都会停止调度，因此必须保证异常被及时处理，为周期性任务提供稳定的调度条件。</p>
<h1 id="线程池实现原理"><a href="#线程池实现原理" class="headerlink" title="线程池实现原理"></a>线程池实现原理</h1><p>newFixedThreadPool或者newCachedThreadPool等线程池内部实现均采用了ThreadPoolExecutor实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>ThreadPoolExecutor构造方法为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">          			  ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>以上几个参数意义如下：</p>
<ul>
<li>corePoolSize ：指定了线程池的核心线程数量</li>
<li>maximumPoolSize：线程池最大数量</li>
<li>long keepAliveTime：当线程数量超过了corePoolSize时候 多余线程的存活时间</li>
<li>workQueue 阻塞队列，被提交但是尚未执行的任务。</li>
<li>threadFactory 线程工厂 一般用默认的即可</li>
<li>handler 拒绝策略。当任务太多时候采用什么拒绝策略。</li>
</ul>
<p>以上的参数大部分很容易理解，其中workQueue它是一个阻塞队列BlockingQueue接口的对象，仅用于存放Runnable对象。根据队列功能分类，在ThreadPoolExecutor的构造函数中可以使用如下几种阻塞队列BlockingQueue：</p>
<ul>
<li><p><strong> 直接提交队列 SynchronousQueue </strong>：该队列是一种特殊的阻塞队列，它没有任何容量，每一个插入操作都要等待一个对应的删除操作，反之删除操作也要等待插入操作，如果是此种阻塞队列，提交的任务不会被真实的保存而是直接交由线程去执行。如果没有空闲线程就新建，达到最大值就采用拒绝策略，使用此种阻塞队列就需要线程池的最大容量特别大否则很容易就去执行拒绝策略。</p>
</li>
<li><p><strong> 有界的任务队列 ArrayBlockigQueue（int capacity） </strong>：这是构造一个有指定capacity容量的阻塞队列，在线程数小于corePoolSize时候会创建新线程，若大于corePoolSize那么就会将新任务加入等待队列，如果等待队列已满且线程数小于MaximumPoolSize的话那么就新建线程去执行任务，大于MaxmumPoolSize的话就执行拒绝策略。可见有界队列仅在任务队列满时候，才有可能将线程数提升到corePoolSize之上。换言之除非系统非常繁忙，否则确保核心线程数维持在CorePoolSize左右。</p>
</li>
<li><p><strong> 无界的任务队列 LinkedBlockingQueue<t>(int capacity or null) </t></strong>:与有界队列相比，无界任务队列LinkedBlockingQueue不存在无法入队的情况（除非系统资源耗尽），当线程数大于CorePoolSize时候新的任务都会进入此队列进行等待，如果任务的创建和执行速度差异很大，该阻塞队列会快速增长直至耗尽系统资源。</p>
</li>
<li><p><strong> 优先任务队列 PriorityBlockingQueue </strong>:PriorityBlockingQueue是一种特殊的无界队列，它可以控制任务执行的先后顺序，它不同于其他先进先出的阻塞队列，它可以根据任务 自身的优先级顺序先后执行，确保系统性能的同时也能有很好的质量保证。</p>
</li>
</ul>
<p>根据如上所述，观看newFixedThreadPool()方法可以看出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                   <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                   <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>它采用的是无界的非阻塞队列，也就是说如果大量地任务进行提交而之前的来不及处理时会耗尽系统资源。<br><code>newSingleThreadExecutor()</code>方法返回单线程池，它是newFixedThreadPool()方法的一种退化，只是简单地将线程池输了设置为1。<br><code>newCachedThreadPool()</code>方法返回corePoolSize为0，maximumPoolSize为无穷大的线程池,这意味着没有任务的时候线程池内无线程，有任务就会使用直接提交队列<code>synchronousBlockingQueue</code>,超大并发提交任务时候会极快地耗尽系统资源。</p>
<pre><code>注意：使用自定义的线程池时候，要根据实际情况选择对应的阻塞队列，这样对系统的影响也不同。
</code></pre><h1 id="JDK的四种线程池拒绝策略"><a href="#JDK的四种线程池拒绝策略" class="headerlink" title="JDK的四种线程池拒绝策略"></a>JDK的四种线程池拒绝策略</h1><ul>
<li>AbortPolicy策略：该策略直接抛出异常，简单粗暴阻止工作。</li>
<li>Cal- lerRunsPolicy 策略:只要线程未关闭，就在当前调用者线程中运行被丢弃的任务。但是这样做会极大地降低调用线程的性能。</li>
<li>Dis- cardOledestPolicy策略：该策略将丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前事务。</li>
<li>Dis- cardPolicy策略：该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，那么可能是最好的一种方案了。</li>
</ul>
<p>以上的内置策略都实现了RejectedExeutionHandler接口，若以上策略仍无法满足实际应用的需要，完全可以自己扩展。</p>
<p><code>ThreadPoolExecutor.AbortPolicy</code>:丢弃任务并抛出RejectedExecutionException异常。<br><code>ThreadPoolExecutor.DiscardPolicy</code>：也是丢弃任务，但是不抛出异常。<br><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）<br><code>ThreadPoolExecutor.CallerRunsPolicy</code>：由调用线程处理该任务 </p>
<p>以上我们介绍的都是默认的ThreadFactory(Executors.defaultThreadFactory())<br>我们也可以自定ThreadFactory 通过重写<code>new ThredFactory(){//...method}</code> 就行。</p>
<h1 id="线程池的扩展"><a href="#线程池的扩展" class="headerlink" title="线程池的扩展"></a>线程池的扩展</h1><p>ThreadPoolExecutor也是一个可扩展的线程池，它提供了<code>beforeExecute()</code>和<code>afterExecute()</code>和<code>terminated()</code>三个接口对线程池进行控制。<code>ThreadPoolExecutor.Worker.runTask()</code>方法内部实现可以看出<code>Worker.runTask()</code>方法会被线程池以多线程模式异步调用，这就使得beforeExecute()和afterExecute接口也将同时多线程访问。下面演示一个通过beforeExecute()和afterExecute()的例子。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池执行实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 圈圈</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorDemo</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Executor1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="keyword">public</span>  String name;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Executor1</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.name=name;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Executor1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				System.out.println(<span class="string">"正在执行的线程ID= "</span>+Thread.currentThread().getId()+<span class="string">" 线程名为:"</span>+name);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">//构建一个线程池执行器实例</span></span><br><span class="line">		ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;())&#123;</span><br><span class="line">			<span class="comment">//线程池运行前调用</span></span><br><span class="line">			<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				<span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">				System.out.println(<span class="string">"准备执行"</span>+((Executor1)r).name);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//运行后调用</span></span><br><span class="line">			<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				<span class="keyword">super</span>.afterExecute(r, t);</span><br><span class="line">				System.out.println(((Executor1)r).name+<span class="string">" 执行完毕"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//线程池退出时调用</span></span><br><span class="line">			<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"线程池退出！"</span>);</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">//用自定义线程池执行器 执行5个线程execute而非submit方法</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">			executor.execute(<span class="keyword">new</span> Executor1(<span class="string">"线程"</span>+i));</span><br><span class="line">			Thread.sleep(<span class="number">800</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//这是比较安全的一个关闭线程池的方法 当然只是发出一个信号 等待执行完成后再停止</span></span><br><span class="line">		executor.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="合理安排线程池大小：优化线程池数量"><a href="#合理安排线程池大小：优化线程池数量" class="headerlink" title="合理安排线程池大小：优化线程池数量"></a>合理安排线程池大小：优化线程池数量</h1><p>只要避免极大和极小两种情况，线程池影响不会太大。<em>《Java Courrency in prictice》</em>中提到估算线程池大小的经验公式：<br><strong> Ncpu=CPU的数量 </strong>  <em>Ucpu =目标CPU的使用率  0-1之间</em>;<br><strong> W/C = 等待时间与计算时间的比率 </strong><br>那么最优线程池的线程数量大小等于<br><strong> Nthreads = Ncpu <em> Ucpu </em> （1+W/C） </strong><br>在 Java中 可以通过<br><code>Runtime.getRuntime().avaliableProcessors()</code> 获取CPU的数量。</p>
<h1 id="线程池中隐蔽的错误"><a href="#线程池中隐蔽的错误" class="headerlink" title="线程池中隐蔽的错误"></a>线程池中隐蔽的错误</h1><p>使用线程池虽然是好事，但是也会让许多异常被“吃掉”了。这样使得排查极为麻烦。例如两数相除分母为0可能使用submit不会打印错误，这时候就要使用execute()方法 可以去堆栈信息中查询异常：<br>这样可以扩展我们的ThreadPoolExecutor 让它在调度任务之前执行打印我们的异常信息。详情看书P115.</p>
<h1 id="分而治之：Fork-Join框架"><a href="#分而治之：Fork-Join框架" class="headerlink" title="分而治之：Fork/Join框架"></a>分而治之：Fork/Join框架</h1><p>分而治之一直是非常有效地处理大数据的方法，著名的MapReduce也是采取分治思想，简单来说就是你没有处理1000个数据的能力，然后你就100个处理分阶段批次处理10次，然后对结果进行合成以达到你要处理1000个数据的能力。Linux中通过fork来创建子进程Java使用ForkJoinPool连接池来管理Fork/Join处理的资源效率，Java中由于线程池的优化，提交任务和线程数量不是一对一的关系，大多数情况下一个物理线程要执行多个逻辑任务，因此每个线程必须要有一个任务队列，例如线程A已经执行完任务了，它就会帮线程B执行任务，线程B就从队列的顶部获取任务，线程A则从队列底部获取任务，这样也避免冲突执行优化。<br>下面是一个ForkJoinPool的一个重要接口：<br><code>public&lt;T&gt; ForkJoinTask&lt;T&gt; submit(ForkJoinTask&lt;T&gt; task)</code><br>这里的ForkJoinTask就是支持fork和join 的等待任务。ForkJoinTask有两个重要子类，RecursiveAction（无返回） 和 RecursiveTask(有返回类型)。它们分别表示没有返回值的任务和可以携带返回值的任务。<br>下面演示一个例子，由于需要返回值 所以采用RecurisiceTask<t>模型:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分治思想</span></span><br><span class="line"><span class="comment"> * Fork / Join  测试</span></span><br><span class="line"><span class="comment"> * Fork/join 框架的使用 这里实例用来计算数列求和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 圈圈</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinDemo</span>  <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	<span class="comment">//设置任务分解的规模  如果大于它就分解 如果小于就直接记录</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THEREHOLD= <span class="number">10000</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ForkJoinDemo</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.start = start;</span><br><span class="line">		<span class="keyword">this</span>.end = end;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//实现抽象方法 返回计算结果</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> sum =<span class="number">0</span> ;</span><br><span class="line">		<span class="comment">//判断是否还需要分区</span></span><br><span class="line">		<span class="keyword">boolean</span> canCompute = (end-start)&lt;THEREHOLD;</span><br><span class="line">		<span class="keyword">if</span>(canCompute)&#123;</span><br><span class="line">			<span class="comment">//如果不需要分区 直接计算</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">long</span> i = start;i&lt;end;i++)&#123;</span><br><span class="line">				sum+=i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//大于10000就需要分区</span></span><br><span class="line">			<span class="comment">//分成100个等规模的小任务 并fork提交</span></span><br><span class="line">			<span class="keyword">long</span> step = (start+end)/<span class="number">100</span>;</span><br><span class="line">			<span class="comment">//构建用于分区的子任务集合list</span></span><br><span class="line">			ArrayList&lt;ForkJoinDemo&gt; list =<span class="keyword">new</span> ArrayList&lt;ForkJoinDemo&gt;();</span><br><span class="line">			<span class="comment">//指针位置</span></span><br><span class="line">			<span class="keyword">long</span> pos = start;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">				<span class="keyword">long</span> lastOne = pos+step;</span><br><span class="line">				<span class="keyword">if</span>(lastOne&gt;end) lastOne=end;</span><br><span class="line">				<span class="comment">//fork分支的子任务</span></span><br><span class="line">				ForkJoinDemo subTask = <span class="keyword">new</span> ForkJoinDemo(pos, lastOne);</span><br><span class="line">				pos+=step+<span class="number">1</span>;</span><br><span class="line">				list.add(subTask);</span><br><span class="line">				<span class="comment">//执行分支</span></span><br><span class="line">				subTask.fork();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//分支执行完 join 收集结果</span></span><br><span class="line">			<span class="keyword">for</span>(ForkJoinDemo fork:list)&#123;</span><br><span class="line">				<span class="comment">//聚集统计总和</span></span><br><span class="line">				sum+=fork.join();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//返回聚集后的结果</span></span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//构建Fork/Join Pool线程池</span></span><br><span class="line">		ForkJoinPool fjpool  = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">		<span class="comment">//构建要分支计算的起始值</span></span><br><span class="line">		ForkJoinDemo demo = <span class="keyword">new</span> ForkJoinDemo(<span class="number">0</span>, <span class="number">200000L</span>);</span><br><span class="line">		<span class="comment">//任务提交给线程池</span></span><br><span class="line">		ForkJoinTask&lt;Long&gt; result = fjpool.submit(demo);</span><br><span class="line">		<span class="comment">//取值</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Long result1 = result.get();</span><br><span class="line">			System.out.println(<span class="string">"总和为："</span>+result1);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<p>使用fork join 时候需要注意，如果任务划分层次很深，一直无返回结果 那么可能有两种情况：<br>1、系统内线程数越积越多 导致性能下降卡顿。<br>2、函数调用层次太深，导致栈溢出。<br>此外，ForkJoin 使用一个无锁的栈来管理空闲线程，如果一个工作线程暂时取不到可用的任务，则可能会被挂起，被压入线程池维护的栈中，待将来有任务可用时再从栈中唤醒这些线程。</p>
<h1 id="JDK的并发容器"><a href="#JDK的并发容器" class="headerlink" title="JDK的并发容器"></a>JDK的并发容器</h1><p>JDK为大家准备了一批好用且平易近人的容器类，它们可以大大地减少开发工作量。如下列举一些：</p>
<ul>
<li>ConcurrentHashMap: 这是一个高效的并发HashMap。你可以理解为一个线程安全的HashMap。</li>
<li>CopyOnWriteArrayList:这是一个List，从名字来看就和ArrayList是一族的。在读多写少的并发场合性能远远好于Vector;</li>
<li>ConcurrentLinkedQueue:高效的并发队列，可以理解为高效的线程安全的LinkedList</li>
<li>BlockingQueue:之前有介绍过几种阻塞队列，这是一个接口，提供了 多种实现以及子接口，非常适合用于作为数据共享的通道。</li>
<li>ConcurrentSkipListMap:跳表的实现，这是一个Map,通过跳表的数据结构进行快速查找。</li>
</ul>
<p>除以上介绍的外。java.util 的Collections工具类也提供了线程安全的转换集合。</p>
<p>ConCurrentLinkedQueue:高并发环境中性能最好的队列就是它了。因为它有很复杂的实现。</p>
<h2 id="高效读取：不变模式下的CopyOnWriteArrayList"><a href="#高效读取：不变模式下的CopyOnWriteArrayList" class="headerlink" title="高效读取：不变模式下的CopyOnWriteArrayList"></a>高效读取：不变模式下的CopyOnWriteArrayList</h2><p>很多应用场景中读操作远远大于写操作，比如有些系统级别的信息 往往只需要加载或者修改很少的次数，但是会被系统内所有模块频繁的访问 这种场景就需要读效率高 写就无所谓了。CopyOnWriteArrayList 这在读写锁上 读写分离的思想上又提升了一步，它读与写之间是可以并行的，但是写与写是互斥的。这样一来读操作性能就大幅提升了。那是怎么实现的呢？顾名思义 从CopyOnWrite可以看出 写操作是将原值复制一份 修改副本   写完之后再将修改后的副本替换掉原来的数据。这样保证写操作不会影响读操作了。<br>查看源码其读操作没有任何锁限制，非常简单。写操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Object[] elements = getArray();</span><br><span class="line">           <span class="keyword">int</span> len = elements.length;</span><br><span class="line">           Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">           newElements[len] = e;</span><br><span class="line">           setArray(newElements);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>是通过重入锁锁住然后创建副本 然后通过setArray修改变量值。 由于array是volatile的所以对读线程可见，读线程能立即察觉。</p>
<h2 id="数据共享通道：BlockingQueue"><a href="#数据共享通道：BlockingQueue" class="headerlink" title="数据共享通道：BlockingQueue"></a>数据共享通道：BlockingQueue</h2><p>BlockingQueue是一个接口，其之所以适合作为数据共享通道还在于他的blocking阻塞上，它会让服务线程在队列为空时，进行等待，当有新的消息进入队列后自动将线程唤醒。这时候就有队列的两个入队方法<br><code>offer()</code>  如果队列满了返回false  不阻塞<br>put()  如果队列满了 就等待阻塞(notFull.await   直到调用take()方法的extract()方法 有空位时候 就有notFull.signal())<br>对应的两个出队方法：<br><code>poll()</code> 如果队列为空返回Null 不阻塞<br><code>take()</code> 如果队列为空 则等待阻塞（对应字段 Condition notEmpty.await()） 直到队列有可用元素（insert()方法有notEmpty.signal()）。<br>BlockingQueue的使用非常普遍，在后续的“5.3”生产者消费者一节中我们还会看到他们的身影，看他们如何使用BlockingQueue解耦生产者和消费者。</p>
<h2 id="随机数据结构：跳表（ConcurrentSkipListMap）"><a href="#随机数据结构：跳表（ConcurrentSkipListMap）" class="headerlink" title="随机数据结构：跳表（ConcurrentSkipListMap）"></a>随机数据结构：跳表（ConcurrentSkipListMap）</h2><p>JDK并发包中除了常见的哈希表以外，还有一种有趣的数据结构—跳表。跳表也是一种用来快速查找的数据结构，有点类似于平衡树。它们都可以对元素进行快速的查找，但一个重要的区别是：对平衡树的插入和删除操作会改变树的整体结构，对跳表的插入和删除操作只改变部分的数据结构，这时候需要一个全局的锁来保证平衡树的安全，对于跳表只需要部分的锁即可。这样在高并发环境下就有更好的性能，就查询性能而言 跳表也是O(log n)所以JDK用跳表实现了一个Map。<br>跳表的另外一个特点是随机算法。跳表的本质是维护了多个链表，并且链表是分层的。例如最底层维护了一张跳表所有元素，往上一层是其子集，一个元素插入哪些层完全是随机的，如果运气不好性能会很糟糕，但实际情况而言它的表现是非常好的。<br>跳表内所有元素是排好序的，通过跳跃式的算法进行查找，例如：<br>查找元素7<br>h –&gt; 3 —&gt; 6<br>h –1 – 3—6 —-8<br>h–1–2–3–4–5–6–7–8<br>跳表会从顶层往下查找，查找元素7发现第一层6，快速跳跃小于7的元素，深入第二层6的位置发现8比7大就直接深入底层查找到了7。整个过程比一般链表从 1 开始逐步遍历要好的多。因此很显然，跳表是一种用空间换时间的方法。<br>使用跳表实现Map和哈希表实现Map区别为 哈希表Map不会保存元素顺序，而跳表会保存，且跳表内所有元素都是有序的，所以如果应用需求需要有序数据 那么跳表是不二选择  具体实现为 ConcurrentSkipListMap。 其内部数据结构主要是 Node<k,v>  Node所有操作均采用CAS，另外还有一个就是Index 通过Index进行全网组织。</k,v></p>

    </article>
    <!-- 前后页  -->
    <ul class="post-pager">
        
            <li class="next">
                <a href= "/2017/08/07/Java并发编程笔记（四）锁的优化及其注意事项/" title= Java并发编程笔记（四）锁的优化及其注意事项 >
                    <span>Next Post</span>
                    <span>Java并发编程笔记（四）锁的优化及其注意事项</span>
                </a>
            </li>
        
        
            <li class="previous">
                <a href= "/2017/06/27/Java并发编程笔记（二）JDK并发包详解1/" title= Java并发编程笔记（二）JDK并发包详解1 >
                    <span>Previous Post</span>
                    <span>Java并发编程笔记（二）JDK并发包详解1</span>
                </a>
            </li>
        
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
<div id="container"></div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    var gitment = new Gitment({
        // id: "Java并发编程笔记（三）JDK并发包详解2", // 可选。默认为 location.href
        owner: 'wycmiko',
        repo: 'blogcomment.github.io',
        oauth: {
            client_id: '712556ec4c3ca7b31d60',
            client_secret: 'bd0aed079e12449eff90ce082144976dbb7ca4d2',
        },
    })
    gitment.render('container')

</script>

    <!--PC版-->

    <!--PC版-->


    
    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:wycmiko@foxmail.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/wycmiko/wycmiko.github.io" class="iconfont-archer github" target="_blank" title="github"></a>
            
        
    
        
            
                <a href="//weibo.com/eversince2012" class="iconfont-archer weibo" target="_blank" title="weibo"></a>
            
        
    
        
            
                <a href="//www.zhihu.com/people/newbee66" class="iconfont-archer zhihu" target="_blank" title="zhihu"></a>
            
        
    
        
            
                <a href="//wycmiko.cn/about" class="iconfont-archer linkedin" target="_blank" title="linkedin"></a>
            
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by 翁玉川 <a href="https://github.com/wycmiko/wycmiko.github.io" target="_blank">@WycMiko</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">个人博客</span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
        <span id="busuanzi_container_site_pv">总访问量: <span id="busuanzi_value_site_pv"></span>
        </span>
    </div>
    
	
	
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper">
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#线程复用：线程池"><span class="toc-number">1.</span> <span class="toc-text">线程复用：线程池</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#不要重复发明轮子：JDK对线程池的支持"><span class="toc-number">2.</span> <span class="toc-text">不要重复发明轮子：JDK对线程池的支持</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程池实现原理"><span class="toc-number">3.</span> <span class="toc-text">线程池实现原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK的四种线程池拒绝策略"><span class="toc-number">4.</span> <span class="toc-text">JDK的四种线程池拒绝策略</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程池的扩展"><span class="toc-number">5.</span> <span class="toc-text">线程池的扩展</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#合理安排线程池大小：优化线程池数量"><span class="toc-number">6.</span> <span class="toc-text">合理安排线程池大小：优化线程池数量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程池中隐蔽的错误"><span class="toc-number">7.</span> <span class="toc-text">线程池中隐蔽的错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分而治之：Fork-Join框架"><span class="toc-number">8.</span> <span class="toc-text">分而治之：Fork/Join框架</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK的并发容器"><span class="toc-number">9.</span> <span class="toc-text">JDK的并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#高效读取：不变模式下的CopyOnWriteArrayList"><span class="toc-number">9.1.</span> <span class="toc-text">高效读取：不变模式下的CopyOnWriteArrayList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据共享通道：BlockingQueue"><span class="toc-number">9.2.</span> <span class="toc-text">数据共享通道：BlockingQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#随机数据结构：跳表（ConcurrentSkipListMap）"><span class="toc-number">9.3.</span> <span class="toc-text">随机数据结构：跳表（ConcurrentSkipListMap）</span></a></li></ol></li></ol>
    </div>
    
    <div class="back-top">&#xe639;</div>
    <div class="sidebar">
    <div class="sidebar-header sidebar-header-show-archive">
        <div class="sidebar-category">
            <span class="sidebar-archive-link"><span class="iconfont-archer">&#xe67d;</span>全部文章</span>
            <span class="sidebar-tags-link"><span class="iconfont-archer">&#xe610;</span>标签</span>
        </div>
    </div>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-archive">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-archive"> 总计 : 28 </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/24</span><a class="archive-post-title" href= "/2018/01/24/Consul vs Zookeeper vs Etcd vs Eureka/" >Consul vs Zookeeper vs Etcd vs Eureka</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/18</span><a class="archive-post-title" href= "/2018/01/18/Spark基础性能调优/" >Spark基础性能调优</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/15</span><a class="archive-post-title" href= "/2018/01/15/分布式流数据处理Kafka-三/" >分布式流数据处理Kafka-三</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/11</span><a class="archive-post-title" href= "/2018/01/11/分布式流数据处理Kafka-二/" >分布式流数据处理Kafka(二)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span><a class="archive-post-title" href= "/2018/01/08/分布式流数据处理Kafka-一/" >分布式流数据处理Kafka(一)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/05</span><a class="archive-post-title" href= "/2018/01/05/Java8与并发2/" >Java8与并发2</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2017 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/28</span><a class="archive-post-title" href= "/2017/12/28/Java8与并发/" >Java8与并发</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/14</span><a class="archive-post-title" href= "/2017/12/14/Java并发编程笔记（九）NIO与AIO2/" >Java并发编程笔记（九）NIO与AIO2</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/11</span><a class="archive-post-title" href= "/2017/11/11/Java并发编程笔记（八）NIO与AIO/" >Java并发编程笔记（八）NIO与AIO</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/07</span><a class="archive-post-title" href= "/2017/10/07/Java并发编程笔记（七）并行模式与算法2/" >Java并发编程笔记（七）并行模式与算法2</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/07</span><a class="archive-post-title" href= "/2017/09/07/Java并发编程笔记（六）并行模式与算法/" >Java并发编程笔记（六）并行模式与算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/17</span><a class="archive-post-title" href= "/2017/08/17/Java并发编程笔记（五）锁的优化及其注意事项2/" >Java并发编程笔记（五）锁的优化及其注意事项2</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/07</span><a class="archive-post-title" href= "/2017/08/07/Java并发编程笔记（四）锁的优化及其注意事项/" >Java并发编程笔记（四）锁的优化及其注意事项</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/01</span><a class="archive-post-title" href= "/2017/07/01/Java并发编程笔记（三）JDK并发包详解2/" >Java并发编程笔记（三）JDK并发包详解2</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/27</span><a class="archive-post-title" href= "/2017/06/27/Java并发编程笔记（二）JDK并发包详解1/" >Java并发编程笔记（二）JDK并发包详解1</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/06</span><a class="archive-post-title" href= "/2017/06/06/Java并发编程笔记（一）基础概念理解/" >Java并发编程笔记（一）基础概念理解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/26</span><a class="archive-post-title" href= "/2017/05/26/缓存那些事儿/" >缓存那些事儿</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/16</span><a class="archive-post-title" href= "/2017/05/16/HBase概念及操作（四）内部表原理以及拆分操作/" >HBase概念及操作（四）内部表原理以及拆分操作</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/06</span><a class="archive-post-title" href= "/2017/05/06/HBase概念及操作（三）HBase JavaAPI以及Shell命令/" >HBase概念及操作（三）HBase JavaAPI以及Shell命令</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/01</span><a class="archive-post-title" href= "/2017/05/01/HBase概念及操作（二）HBase安装体验/" >HBase概念及操作（二）HBase安装体验</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/01</span><a class="archive-post-title" href= "/2017/04/01/HBase概念及操作（一）HBase基本概念及原理/" >HBase概念及操作（一）HBase基本概念及原理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/30</span><a class="archive-post-title" href= "/2017/03/30/JVM总体梳理/" >JVM总体梳理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/22</span><a class="archive-post-title" href= "/2017/03/22/浅谈Redis部分应用/" >浅谈Redis部分应用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/01</span><a class="archive-post-title" href= "/2017/03/01/docker基本使用/" >docker基本使用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/25</span><a class="archive-post-title" href= "/2017/02/25/超快速KV-NOSQL-LevelDB/" >超快速KV NOSQL-LevelDB</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/11</span><a class="archive-post-title" href= "/2017/02/11/区块链概念（二）/" >区块链概念（二）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/11</span><a class="archive-post-title" href= "/2017/02/11/区块链概念（一）/" >区块链概念（一）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/21</span><a class="archive-post-title" href= "/2017/01/21/密码学原理/" >密码学原理</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name"><a href= "#">服务治理</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">大数据</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">HBase</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">JVM虚拟机</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">Java8特性</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">函数式编程</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">并发编程</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">算法</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">设计模式</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">网络通信</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">Spark</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">性能调优</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">kafka</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">分布式</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">区块链</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">密码学</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">Redis</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">Hadoop</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">NoSQL</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">LevelDB</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">缓存</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">优化</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">docker</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">容器</a></span>
    
    </div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: false
    tags: true</pre>
    </div> 
    <div class="sidebar-tag-list"></div>
</div>
    </div>
</div> 
    <script>
    var jsInfo = {
        root: '/'
    }
</script>
    <!-- 不蒜子  -->
    
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ统计  -->
    
    </div>
    </body>
</html>


